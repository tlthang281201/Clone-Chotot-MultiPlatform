{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { createSlice } from \"@reduxjs/toolkit\";\nvar initialState = {\n  value: {}\n};\nexport var counterSlice = createSlice({\n  name: \"counter\",\n  initialState: initialState,\n  reducers: {\n    increment: function increment(state) {\n      state.value = _objectSpread(_objectSpread({}, state.value), {}, {\n        value: {\n          a: 2,\n          b: 3\n        }\n      });\n    },\n    decrement: function decrement(state) {\n      state.value = _objectSpread(_objectSpread({}, state.value), {}, {\n        value: {\n          a: 1,\n          b: 4\n        }\n      });\n    },\n    incrementByAmount: function incrementByAmount(state, action) {\n      state.value += action.payload;\n    }\n  }\n});\n\nvar _counterSlice$actions = counterSlice.actions,\n  increment = _counterSlice$actions.increment,\n  decrement = _counterSlice$actions.decrement,\n  incrementByAmount = _counterSlice$actions.incrementByAmount;\nexport { increment, decrement, incrementByAmount };\nexport default counterSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","value","counterSlice","name","reducers","increment","state","a","b","decrement","incrementByAmount","action","payload","actions","reducer"],"sources":["F:/DoAn/DACN1/ShopApp/src/Redux/slice.js"],"sourcesContent":["import { createSlice } from \"@reduxjs/toolkit\";\r\n\r\nconst initialState = {\r\n  value: {},\r\n};\r\n\r\nexport const counterSlice = createSlice({\r\n  name: \"counter\",\r\n  initialState,\r\n  reducers: {\r\n    increment: (state) => {\r\n      // Redux Toolkit allows us to write \"mutating\" logic in reducers. It\r\n      // doesn't actually mutate the state because it uses the Immer library,\r\n      // which detects changes to a \"draft state\" and produces a brand new\r\n      // immutable state based off those changes\r\n      state.value = { ...state.value, value: { a: 2, b: 3 } };\r\n    },\r\n    decrement: (state) => {\r\n      state.value = { ...state.value, value: { a: 1, b: 4 } };\r\n    },\r\n    incrementByAmount: (state, action) => {\r\n      state.value += action.payload;\r\n    },\r\n  },\r\n});\r\n\r\n// Action creators are generated for each case reducer function\r\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions;\r\n\r\nexport default counterSlice.reducer;\r\n"],"mappings":";;;AAAA,SAASA,WAAW,QAAQ,kBAAkB;AAE9C,IAAMC,YAAY,GAAG;EACnBC,KAAK,EAAE,CAAC;AACV,CAAC;AAED,OAAO,IAAMC,YAAY,GAAGH,WAAW,CAAC;EACtCI,IAAI,EAAE,SAAS;EACfH,YAAY,EAAZA,YAAY;EACZI,QAAQ,EAAE;IACRC,SAAS,EAAE,mBAACC,KAAK,EAAK;MAKpBA,KAAK,CAACL,KAAK,mCAAQK,KAAK,CAACL,KAAK;QAAEA,KAAK,EAAE;UAAEM,CAAC,EAAE,CAAC;UAAEC,CAAC,EAAE;QAAE;MAAC,EAAE;IACzD,CAAC;IACDC,SAAS,EAAE,mBAACH,KAAK,EAAK;MACpBA,KAAK,CAACL,KAAK,mCAAQK,KAAK,CAACL,KAAK;QAAEA,KAAK,EAAE;UAAEM,CAAC,EAAE,CAAC;UAAEC,CAAC,EAAE;QAAE;MAAC,EAAE;IACzD,CAAC;IACDE,iBAAiB,EAAE,2BAACJ,KAAK,EAAEK,MAAM,EAAK;MACpCL,KAAK,CAACL,KAAK,IAAIU,MAAM,CAACC,OAAO;IAC/B;EACF;AACF,CAAC,CAAC;;AAGK,4BAAoDV,YAAY,CAACW,OAAO;EAAhER,SAAS,yBAATA,SAAS;EAAEI,SAAS,yBAATA,SAAS;EAAEC,iBAAiB,yBAAjBA,iBAAiB;AAA0B;AAEhF,eAAeR,YAAY,CAACY,OAAO"},"metadata":{},"sourceType":"module"}
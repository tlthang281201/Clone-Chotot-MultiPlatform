{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"timing\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport Keyboard from \"react-native-web/dist/exports/Keyboard\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport View from \"react-native-web/dist/exports/View\";\nimport useAnimatedValue from \"./useAnimatedValue\";\nvar DEAD_ZONE = 12;\nvar DefaultTransitionSpec = {\n  timing: Animated.spring,\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true\n};\nexport default function PanResponderAdapter(_ref) {\n  var layout = _ref.layout,\n    _ref$keyboardDismissM = _ref.keyboardDismissMode,\n    keyboardDismissMode = _ref$keyboardDismissM === void 0 ? 'auto' : _ref$keyboardDismissM,\n    _ref$swipeEnabled = _ref.swipeEnabled,\n    swipeEnabled = _ref$swipeEnabled === void 0 ? true : _ref$swipeEnabled,\n    navigationState = _ref.navigationState,\n    onIndexChange = _ref.onIndexChange,\n    onSwipeStart = _ref.onSwipeStart,\n    onSwipeEnd = _ref.onSwipeEnd,\n    children = _ref.children,\n    style = _ref.style,\n    _ref$animationEnabled = _ref.animationEnabled,\n    animationEnabled = _ref$animationEnabled === void 0 ? false : _ref$animationEnabled;\n  var routes = navigationState.routes,\n    index = navigationState.index;\n  var panX = useAnimatedValue(0);\n  var listenersRef = React.useRef([]);\n  var navigationStateRef = React.useRef(navigationState);\n  var layoutRef = React.useRef(layout);\n  var onIndexChangeRef = React.useRef(onIndexChange);\n  var currentIndexRef = React.useRef(index);\n  var pendingIndexRef = React.useRef();\n  var swipeVelocityThreshold = 0.15;\n  var swipeDistanceThreshold = layout.width / 1.75;\n  var jumpToIndex = React.useCallback(function (index) {\n    var animate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : animationEnabled;\n    var offset = -index * layoutRef.current.width;\n    var timing = DefaultTransitionSpec.timing,\n      transitionConfig = _objectWithoutProperties(DefaultTransitionSpec, _excluded);\n    if (animate) {\n      Animated.parallel([timing(panX, _objectSpread(_objectSpread({}, transitionConfig), {}, {\n        toValue: offset,\n        useNativeDriver: false\n      }))]).start(function (_ref2) {\n        var finished = _ref2.finished;\n        if (finished) {\n          onIndexChangeRef.current(index);\n          pendingIndexRef.current = undefined;\n        }\n      });\n      pendingIndexRef.current = index;\n    } else {\n      panX.setValue(offset);\n      onIndexChangeRef.current(index);\n      pendingIndexRef.current = undefined;\n    }\n  }, [animationEnabled, panX]);\n  React.useEffect(function () {\n    navigationStateRef.current = navigationState;\n    layoutRef.current = layout;\n    onIndexChangeRef.current = onIndexChange;\n  });\n  React.useEffect(function () {\n    var offset = -navigationStateRef.current.index * layout.width;\n    panX.setValue(offset);\n  }, [layout.width, panX]);\n  React.useEffect(function () {\n    if (keyboardDismissMode === 'auto') {\n      Keyboard.dismiss();\n    }\n    if (layout.width && currentIndexRef.current !== index) {\n      currentIndexRef.current = index;\n      jumpToIndex(index);\n    }\n  }, [jumpToIndex, keyboardDismissMode, layout.width, index]);\n  var isMovingHorizontally = function isMovingHorizontally(_, gestureState) {\n    return Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 2) && Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 2);\n  };\n  var canMoveScreen = function canMoveScreen(event, gestureState) {\n    if (swipeEnabled === false) {\n      return false;\n    }\n    var diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n    return isMovingHorizontally(event, gestureState) && (diffX >= DEAD_ZONE && currentIndexRef.current > 0 || diffX <= -DEAD_ZONE && currentIndexRef.current < routes.length - 1);\n  };\n  var startGesture = function startGesture() {\n    onSwipeStart === null || onSwipeStart === void 0 ? void 0 : onSwipeStart();\n    if (keyboardDismissMode === 'on-drag') {\n      Keyboard.dismiss();\n    }\n    panX.stopAnimation();\n\n    panX.setOffset(panX._value);\n  };\n  var respondToGesture = function respondToGesture(_, gestureState) {\n    var diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n    if (\n    diffX > 0 && index <= 0 ||\n    diffX < 0 && index >= routes.length - 1) {\n      return;\n    }\n    if (layout.width) {\n      var _position = (panX._offset + diffX) / -layout.width;\n      var next = _position > index ? Math.ceil(_position) : Math.floor(_position);\n      if (next !== index) {\n        listenersRef.current.forEach(function (listener) {\n          return listener(next);\n        });\n      }\n    }\n    panX.setValue(diffX);\n  };\n  var finishGesture = function finishGesture(_, gestureState) {\n    panX.flattenOffset();\n    onSwipeEnd === null || onSwipeEnd === void 0 ? void 0 : onSwipeEnd();\n    var currentIndex = typeof pendingIndexRef.current === 'number' ? pendingIndexRef.current : currentIndexRef.current;\n    var nextIndex = currentIndex;\n    if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.vx) > Math.abs(gestureState.vy) && (Math.abs(gestureState.dx) > swipeDistanceThreshold || Math.abs(gestureState.vx) > swipeVelocityThreshold)) {\n      nextIndex = Math.round(Math.min(Math.max(0, I18nManager.isRTL ? currentIndex + gestureState.dx / Math.abs(gestureState.dx) : currentIndex - gestureState.dx / Math.abs(gestureState.dx)), routes.length - 1));\n      currentIndexRef.current = nextIndex;\n    }\n    if (!isFinite(nextIndex)) {\n      nextIndex = currentIndex;\n    }\n    jumpToIndex(nextIndex, true);\n  };\n\n  var addEnterListener = React.useCallback(function (listener) {\n    listenersRef.current.push(listener);\n    return function () {\n      var index = listenersRef.current.indexOf(listener);\n      if (index > -1) {\n        listenersRef.current.splice(index, 1);\n      }\n    };\n  }, []);\n  var jumpTo = React.useCallback(function (key) {\n    var index = navigationStateRef.current.routes.findIndex(function (route) {\n      return route.key === key;\n    });\n    jumpToIndex(index);\n  }, [jumpToIndex]);\n  var panResponder = PanResponder.create({\n    onMoveShouldSetPanResponder: canMoveScreen,\n    onMoveShouldSetPanResponderCapture: canMoveScreen,\n    onPanResponderGrant: startGesture,\n    onPanResponderMove: respondToGesture,\n    onPanResponderTerminate: finishGesture,\n    onPanResponderRelease: finishGesture,\n    onPanResponderTerminationRequest: function onPanResponderTerminationRequest() {\n      return true;\n    }\n  });\n  var maxTranslate = layout.width * (routes.length - 1);\n  var translateX = Animated.multiply(panX.interpolate({\n    inputRange: [-maxTranslate, 0],\n    outputRange: [-maxTranslate, 0],\n    extrapolate: 'clamp'\n  }), I18nManager.isRTL ? -1 : 1);\n  var position = React.useMemo(function () {\n    return layout.width ? Animated.divide(panX, -layout.width) : null;\n  }, [layout.width, panX]);\n  return children({\n    position: position != null ? position : new Animated.Value(index),\n    addEnterListener: addEnterListener,\n    jumpTo: jumpTo,\n    render: function render(children) {\n      return React.createElement(Animated.View, _extends({\n        style: [styles.sheet, layout.width ? {\n          width: routes.length * layout.width,\n          transform: [{\n            translateX: translateX\n          }]\n        } : null, style]\n      }, panResponder.panHandlers), React.Children.map(children, function (child, i) {\n        var route = routes[i];\n        var focused = i === index;\n        return React.createElement(View, {\n          key: route.key,\n          style: layout.width ? {\n            width: layout.width\n          } : focused ? StyleSheet.absoluteFill : null\n        }, focused || layout.width ? child : null);\n      }));\n    }\n  });\n}\nvar styles = StyleSheet.create({\n  sheet: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'stretch'\n  }\n});","map":{"version":3,"sources":["PanResponderAdapter.tsx"],"names":["React","useAnimatedValue","DEAD_ZONE","DefaultTransitionSpec","timing","Animated","spring","stiffness","damping","mass","overshootClamping","PanResponderAdapter","layout","keyboardDismissMode","swipeEnabled","navigationState","onIndexChange","onSwipeStart","onSwipeEnd","children","style","animationEnabled","routes","index","panX","listenersRef","useRef","navigationStateRef","layoutRef","onIndexChangeRef","currentIndexRef","pendingIndexRef","swipeVelocityThreshold","swipeDistanceThreshold","width","jumpToIndex","useCallback","animate","offset","current","transitionConfig","parallel","toValue","useNativeDriver","start","finished","undefined","setValue","useEffect","Keyboard","dismiss","isMovingHorizontally","_","gestureState","Math","abs","dx","dy","vx","vy","canMoveScreen","event","diffX","I18nManager","isRTL","length","startGesture","stopAnimation","setOffset","_value","respondToGesture","position","_offset","next","ceil","floor","forEach","listener","finishGesture","flattenOffset","currentIndex","nextIndex","round","min","max","isFinite","addEnterListener","push","indexOf","splice","jumpTo","key","findIndex","route","panResponder","create","onMoveShouldSetPanResponder","onMoveShouldSetPanResponderCapture","onPanResponderGrant","onPanResponderMove","onPanResponderTerminate","onPanResponderRelease","onPanResponderTerminationRequest","maxTranslate","translateX","multiply","interpolate","inputRange","outputRange","extrapolate","useMemo","divide","Value","render","styles","sheet","transform","panHandlers","Children","map","child","i","focused","StyleSheet","absoluteFill","flex","flexDirection","alignItems"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  PanResponder,\n  Keyboard,\n  StyleSheet,\n  GestureResponderEvent,\n  PanResponderGestureState,\n  I18nManager,\n  View,\n} from 'react-native';\nimport useAnimatedValue from './useAnimatedValue';\nimport type {\n  NavigationState,\n  Route,\n  Layout,\n  EventEmitterProps,\n  PagerProps,\n  Listener,\n} from './types';\n\ntype Props<T extends Route> = PagerProps & {\n  layout: Layout;\n  onIndexChange: (index: number) => void;\n  navigationState: NavigationState<T>;\n  children: (\n    props: EventEmitterProps & {\n      // Animated value which represents the state of current index\n      // It can include fractional digits as it represents the intermediate value\n      position: Animated.AnimatedInterpolation;\n      // Function to actually render the content of the pager\n      // The parent component takes care of rendering\n      render: (children: React.ReactNode) => React.ReactNode;\n      // Callback to call when switching the tab\n      // The tab switch animation is performed even if the index in state is unchanged\n      jumpTo: (key: string) => void;\n    }\n  ) => React.ReactElement;\n};\n\nconst DEAD_ZONE = 12;\n\nconst DefaultTransitionSpec = {\n  timing: Animated.spring,\n  stiffness: 1000,\n  damping: 500,\n  mass: 3,\n  overshootClamping: true,\n};\n\nexport default function PanResponderAdapter<T extends Route>({\n  layout,\n  keyboardDismissMode = 'auto',\n  swipeEnabled = true,\n  navigationState,\n  onIndexChange,\n  onSwipeStart,\n  onSwipeEnd,\n  children,\n  style,\n  animationEnabled = false,\n}: Props<T>) {\n  const { routes, index } = navigationState;\n\n  const panX = useAnimatedValue(0);\n\n  const listenersRef = React.useRef<Listener[]>([]);\n\n  const navigationStateRef = React.useRef(navigationState);\n  const layoutRef = React.useRef(layout);\n  const onIndexChangeRef = React.useRef(onIndexChange);\n\n  const currentIndexRef = React.useRef(index);\n  const pendingIndexRef = React.useRef<number>();\n\n  const swipeVelocityThreshold = 0.15;\n  const swipeDistanceThreshold = layout.width / 1.75;\n\n  const jumpToIndex = React.useCallback(\n    (index: number, animate = animationEnabled) => {\n      const offset = -index * layoutRef.current.width;\n\n      const { timing, ...transitionConfig } = DefaultTransitionSpec;\n\n      if (animate) {\n        Animated.parallel([\n          timing(panX, {\n            ...transitionConfig,\n            toValue: offset,\n            useNativeDriver: false,\n          }),\n        ]).start(({ finished }) => {\n          if (finished) {\n            onIndexChangeRef.current(index);\n            pendingIndexRef.current = undefined;\n          }\n        });\n        pendingIndexRef.current = index;\n      } else {\n        panX.setValue(offset);\n        onIndexChangeRef.current(index);\n        pendingIndexRef.current = undefined;\n      }\n    },\n    [animationEnabled, panX]\n  );\n\n  React.useEffect(() => {\n    navigationStateRef.current = navigationState;\n    layoutRef.current = layout;\n    onIndexChangeRef.current = onIndexChange;\n  });\n\n  React.useEffect(() => {\n    const offset = -navigationStateRef.current.index * layout.width;\n\n    panX.setValue(offset);\n  }, [layout.width, panX]);\n\n  React.useEffect(() => {\n    if (keyboardDismissMode === 'auto') {\n      Keyboard.dismiss();\n    }\n\n    if (layout.width && currentIndexRef.current !== index) {\n      currentIndexRef.current = index;\n      jumpToIndex(index);\n    }\n  }, [jumpToIndex, keyboardDismissMode, layout.width, index]);\n\n  const isMovingHorizontally = (\n    _: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    return (\n      Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 2) &&\n      Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 2)\n    );\n  };\n\n  const canMoveScreen = (\n    event: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    if (swipeEnabled === false) {\n      return false;\n    }\n\n    const diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n\n    return (\n      isMovingHorizontally(event, gestureState) &&\n      ((diffX >= DEAD_ZONE && currentIndexRef.current > 0) ||\n        (diffX <= -DEAD_ZONE && currentIndexRef.current < routes.length - 1))\n    );\n  };\n\n  const startGesture = () => {\n    onSwipeStart?.();\n\n    if (keyboardDismissMode === 'on-drag') {\n      Keyboard.dismiss();\n    }\n\n    panX.stopAnimation();\n    // @ts-expect-error: _value is private, but docs use it as well\n    panX.setOffset(panX._value);\n  };\n\n  const respondToGesture = (\n    _: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    const diffX = I18nManager.isRTL ? -gestureState.dx : gestureState.dx;\n\n    if (\n      // swiping left\n      (diffX > 0 && index <= 0) ||\n      // swiping right\n      (diffX < 0 && index >= routes.length - 1)\n    ) {\n      return;\n    }\n\n    if (layout.width) {\n      // @ts-expect-error: _offset is private, but docs use it as well\n      const position = (panX._offset + diffX) / -layout.width;\n      const next =\n        position > index ? Math.ceil(position) : Math.floor(position);\n\n      if (next !== index) {\n        listenersRef.current.forEach((listener) => listener(next));\n      }\n    }\n\n    panX.setValue(diffX);\n  };\n\n  const finishGesture = (\n    _: GestureResponderEvent,\n    gestureState: PanResponderGestureState\n  ) => {\n    panX.flattenOffset();\n\n    onSwipeEnd?.();\n\n    const currentIndex =\n      typeof pendingIndexRef.current === 'number'\n        ? pendingIndexRef.current\n        : currentIndexRef.current;\n\n    let nextIndex = currentIndex;\n\n    if (\n      Math.abs(gestureState.dx) > Math.abs(gestureState.dy) &&\n      Math.abs(gestureState.vx) > Math.abs(gestureState.vy) &&\n      (Math.abs(gestureState.dx) > swipeDistanceThreshold ||\n        Math.abs(gestureState.vx) > swipeVelocityThreshold)\n    ) {\n      nextIndex = Math.round(\n        Math.min(\n          Math.max(\n            0,\n            I18nManager.isRTL\n              ? currentIndex + gestureState.dx / Math.abs(gestureState.dx)\n              : currentIndex - gestureState.dx / Math.abs(gestureState.dx)\n          ),\n          routes.length - 1\n        )\n      );\n\n      currentIndexRef.current = nextIndex;\n    }\n\n    if (!isFinite(nextIndex)) {\n      nextIndex = currentIndex;\n    }\n\n    jumpToIndex(nextIndex, true);\n  };\n\n  // TODO: use the listeners\n  const addEnterListener = React.useCallback((listener: Listener) => {\n    listenersRef.current.push(listener);\n\n    return () => {\n      const index = listenersRef.current.indexOf(listener);\n\n      if (index > -1) {\n        listenersRef.current.splice(index, 1);\n      }\n    };\n  }, []);\n\n  const jumpTo = React.useCallback(\n    (key: string) => {\n      const index = navigationStateRef.current.routes.findIndex(\n        (route: { key: string }) => route.key === key\n      );\n\n      jumpToIndex(index);\n    },\n    [jumpToIndex]\n  );\n\n  const panResponder = PanResponder.create({\n    onMoveShouldSetPanResponder: canMoveScreen,\n    onMoveShouldSetPanResponderCapture: canMoveScreen,\n    onPanResponderGrant: startGesture,\n    onPanResponderMove: respondToGesture,\n    onPanResponderTerminate: finishGesture,\n    onPanResponderRelease: finishGesture,\n    onPanResponderTerminationRequest: () => true,\n  });\n\n  const maxTranslate = layout.width * (routes.length - 1);\n  const translateX = Animated.multiply(\n    panX.interpolate({\n      inputRange: [-maxTranslate, 0],\n      outputRange: [-maxTranslate, 0],\n      extrapolate: 'clamp',\n    }),\n    I18nManager.isRTL ? -1 : 1\n  );\n\n  const position = React.useMemo(\n    () => (layout.width ? Animated.divide(panX, -layout.width) : null),\n    [layout.width, panX]\n  );\n\n  return children({\n    position: position ?? new Animated.Value(index),\n    addEnterListener,\n    jumpTo,\n    render: (children) => (\n      <Animated.View\n        style={[\n          styles.sheet,\n          layout.width\n            ? {\n                width: routes.length * layout.width,\n                transform: [{ translateX }],\n              }\n            : null,\n          style,\n        ]}\n        {...panResponder.panHandlers}\n      >\n        {React.Children.map(children, (child, i) => {\n          const route = routes[i];\n          const focused = i === index;\n\n          return (\n            <View\n              key={route.key}\n              style={\n                layout.width\n                  ? { width: layout.width }\n                  : focused\n                  ? StyleSheet.absoluteFill\n                  : null\n              }\n            >\n              {focused || layout.width ? child : null}\n            </View>\n          );\n        })}\n      </Animated.View>\n    ),\n  });\n}\n\nconst styles = StyleSheet.create({\n  sheet: {\n    flex: 1,\n    flexDirection: 'row',\n    alignItems: 'stretch',\n  },\n});\n"]},"metadata":{},"sourceType":"module"}
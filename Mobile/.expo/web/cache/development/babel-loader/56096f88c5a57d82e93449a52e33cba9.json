{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { snapValueToStep as $aTwux$snapValueToStep, clamp as $aTwux$clamp } from \"@react-aria/utils\";\nimport { useControlledState as $aTwux$useControlledState } from \"@react-stately/utils\";\nimport { useMemo as $aTwux$useMemo, useState as $aTwux$useState, useRef as $aTwux$useRef } from \"react\";\nvar $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE = 0;\nvar $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE = 100;\nvar $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE = 1;\nfunction $28f99e3e86e6ec45$export$e5fda3247f5d67f9(props) {\n  var _props$isDisabled = props.isDisabled,\n    isDisabled = _props$isDisabled === void 0 ? false : _props$isDisabled,\n    _props$minValue = props.minValue,\n    minValue = _props$minValue === void 0 ? $28f99e3e86e6ec45$var$DEFAULT_MIN_VALUE : _props$minValue,\n    _props$maxValue = props.maxValue,\n    maxValue = _props$maxValue === void 0 ? $28f99e3e86e6ec45$var$DEFAULT_MAX_VALUE : _props$maxValue,\n    formatter = props.numberFormatter,\n    _props$step = props.step,\n    step = _props$step === void 0 ? $28f99e3e86e6ec45$var$DEFAULT_STEP_VALUE : _props$step,\n    _props$orientation = props.orientation,\n    orientation = _props$orientation === void 0 ? 'horizontal' : _props$orientation;\n  var pageSize = $aTwux$useMemo(function () {\n    var calcPageSize = (maxValue - minValue) / 10;\n    calcPageSize = $aTwux$snapValueToStep(calcPageSize, 0, calcPageSize + step, step);\n    return Math.max(calcPageSize, step);\n  }, [step, maxValue, minValue]);\n  var value1 = $aTwux$useMemo(function () {\n    return $28f99e3e86e6ec45$var$convertValue(props.value);\n  }, [props.value]);\n  var ref;\n  var defaultValue = $aTwux$useMemo(function () {\n    return (ref = $28f99e3e86e6ec45$var$convertValue(props.defaultValue)) !== null && ref !== void 0 ? ref : [minValue];\n  }, [props.defaultValue, minValue]);\n  var onChange = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChange);\n  var onChangeEnd = $28f99e3e86e6ec45$var$createOnChange(props.value, props.defaultValue, props.onChangeEnd);\n  var _$aTwux$useControlled = $aTwux$useControlledState(value1, defaultValue, onChange),\n    _$aTwux$useControlled2 = _slicedToArray(_$aTwux$useControlled, 2),\n    values = _$aTwux$useControlled2[0],\n    setValues = _$aTwux$useControlled2[1];\n  var _$aTwux$useState = $aTwux$useState(new Array(values.length).fill(false)),\n    _$aTwux$useState2 = _slicedToArray(_$aTwux$useState, 2),\n    isDraggings = _$aTwux$useState2[0],\n    setDraggings = _$aTwux$useState2[1];\n  var isEditablesRef = $aTwux$useRef(new Array(values.length).fill(true));\n  var _$aTwux$useState3 = $aTwux$useState(undefined),\n    _$aTwux$useState4 = _slicedToArray(_$aTwux$useState3, 2),\n    focusedIndex = _$aTwux$useState4[0],\n    setFocusedIndex = _$aTwux$useState4[1];\n  var valuesRef = $aTwux$useRef(null);\n  valuesRef.current = values;\n  var isDraggingsRef = $aTwux$useRef(null);\n  isDraggingsRef.current = isDraggings;\n  function getValuePercent(value) {\n    return (value - minValue) / (maxValue - minValue);\n  }\n  function getThumbMinValue(index) {\n    return index === 0 ? minValue : values[index - 1];\n  }\n  function getThumbMaxValue(index) {\n    return index === values.length - 1 ? maxValue : values[index + 1];\n  }\n  function isThumbEditable(index) {\n    return isEditablesRef.current[index];\n  }\n  function setThumbEditable(index, editable) {\n    isEditablesRef.current[index] = editable;\n  }\n  function updateValue(index, value) {\n    if (isDisabled || !isThumbEditable(index)) return;\n    var thisMin = getThumbMinValue(index);\n    var thisMax = getThumbMaxValue(index);\n    value = $aTwux$snapValueToStep(value, thisMin, thisMax, step);\n    valuesRef.current = $28f99e3e86e6ec45$var$replaceIndex(valuesRef.current, index, value);\n    setValues(valuesRef.current);\n  }\n  function updateDragging(index, dragging) {\n    if (isDisabled || !isThumbEditable(index)) return;\n    var wasDragging = isDraggingsRef.current[index];\n    isDraggingsRef.current = $28f99e3e86e6ec45$var$replaceIndex(isDraggingsRef.current, index, dragging);\n    setDraggings(isDraggingsRef.current);\n    if (onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) onChangeEnd(valuesRef.current);\n  }\n  function getFormattedValue(value) {\n    return formatter.format(value);\n  }\n  function setThumbPercent(index, percent) {\n    updateValue(index, getPercentValue(percent));\n  }\n  function getRoundedValue(value) {\n    return Math.round((value - minValue) / step) * step + minValue;\n  }\n  function getPercentValue(percent) {\n    var val = percent * (maxValue - minValue) + minValue;\n    return $aTwux$clamp(getRoundedValue(val), minValue, maxValue);\n  }\n  function incrementThumb(index) {\n    var stepSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var s = Math.max(stepSize, step);\n    updateValue(index, $aTwux$snapValueToStep(values[index] + s, minValue, maxValue, step));\n  }\n  function decrementThumb(index) {\n    var stepSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var s = Math.max(stepSize, step);\n    updateValue(index, $aTwux$snapValueToStep(values[index] - s, minValue, maxValue, step));\n  }\n  return {\n    values: values,\n    getThumbValue: function getThumbValue(index) {\n      return values[index];\n    },\n    setThumbValue: updateValue,\n    setThumbPercent: setThumbPercent,\n    isThumbDragging: function isThumbDragging(index) {\n      return isDraggings[index];\n    },\n    setThumbDragging: updateDragging,\n    focusedThumb: focusedIndex,\n    setFocusedThumb: setFocusedIndex,\n    getThumbPercent: function getThumbPercent(index) {\n      return getValuePercent(values[index]);\n    },\n    getValuePercent: getValuePercent,\n    getThumbValueLabel: function getThumbValueLabel(index) {\n      return getFormattedValue(values[index]);\n    },\n    getFormattedValue: getFormattedValue,\n    getThumbMinValue: getThumbMinValue,\n    getThumbMaxValue: getThumbMaxValue,\n    getPercentValue: getPercentValue,\n    isThumbEditable: isThumbEditable,\n    setThumbEditable: setThumbEditable,\n    incrementThumb: incrementThumb,\n    decrementThumb: decrementThumb,\n    step: step,\n    pageSize: pageSize,\n    orientation: orientation,\n    isDisabled: isDisabled\n  };\n}\nfunction $28f99e3e86e6ec45$var$replaceIndex(array, index, value) {\n  if (array[index] === value) return array;\n  return [].concat(_toConsumableArray(array.slice(0, index)), [value], _toConsumableArray(array.slice(index + 1)));\n}\nfunction $28f99e3e86e6ec45$var$convertValue(value) {\n  if (value == null) return undefined;\n  return Array.isArray(value) ? value : [value];\n}\nfunction $28f99e3e86e6ec45$var$createOnChange(value, defaultValue, onChange) {\n  return function (newValue) {\n    if (typeof value === 'number' || typeof defaultValue === 'number') onChange === null || onChange === void 0 ? void 0 : onChange(newValue[0]);else onChange === null || onChange === void 0 ? void 0 : onChange(newValue);\n  };\n}\nexport { $28f99e3e86e6ec45$export$e5fda3247f5d67f9 as useSliderState };","map":{"version":3,"sources":["packages/@react-stately/slider/src/useSliderState.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {clamp, snapValueToStep} from '@react-aria/utils';\nimport {Orientation} from '@react-types/shared';\nimport {SliderProps} from '@react-types/slider';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo, useRef, useState} from 'react';\n\nexport interface SliderState {\n  /**\n   * Values managed by the slider by thumb index.\n   */\n  readonly values: number[],\n  /**\n   * Get the value for the specified thumb.\n   * @param index\n   */\n  getThumbValue(index: number): number,\n\n  /**\n   * Sets the value for the specified thumb.\n   * The actual value set will be clamped and rounded according to min/max/step.\n   * @param index\n   * @param value\n   */\n  setThumbValue(index: number, value: number): void,\n\n  /**\n   * Sets value for the specified thumb by percent offset (between 0 and 1).\n   * @param index\n   * @param percent\n   */\n  setThumbPercent(index: number, percent: number): void,\n\n  /**\n   * Whether the specific thumb is being dragged.\n   * @param index\n   */\n  isThumbDragging(index: number): boolean,\n  /**\n   * Set is dragging on the specified thumb.\n   * @param index\n   * @param dragging\n   */\n  setThumbDragging(index: number, dragging: boolean): void,\n\n  /**\n   * Currently-focused thumb index.\n   */\n  readonly focusedThumb: number | undefined,\n  /**\n   * Set focused true on specified thumb. This will remove focus from\n   * any thumb that had it before.\n   * @param index\n   */\n  setFocusedThumb(index: number | undefined): void,\n\n  /**\n   * Returns the specified thumb's value as a percentage from 0 to 1.\n   * @param index\n   */\n  getThumbPercent(index: number): number,\n\n  /**\n   * Returns the value as a percent between the min and max of the slider.\n   * @param index\n   */\n  getValuePercent(value: number): number,\n\n  /**\n   * Returns the string label for the specified thumb's value, per props.formatOptions.\n   * @param index\n   */\n  getThumbValueLabel(index: number): string,\n\n  /**\n   * Returns the string label for the value, per props.formatOptions.\n   * @param index\n   */\n  getFormattedValue(value: number): string,\n\n  /**\n   * Returns the min allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMinValue(index: number): number,\n\n  /**\n   * Returns the max allowed value for the specified thumb.\n   * @param index\n   */\n  getThumbMaxValue(index: number): number,\n\n  /**\n   * Converts a percent along track (between 0 and 1) to the corresponding value.\n   * @param percent\n   */\n  getPercentValue(percent: number): number,\n\n  /**\n   * Returns if the specified thumb is editable.\n   * @param index\n   */\n  isThumbEditable(index: number): boolean,\n\n  /**\n   * Set the specified thumb's editable state.\n   * @param index\n   * @param editable\n   */\n  setThumbEditable(index: number, editable: boolean): void,\n\n  /**\n   * Increments the value of the thumb by the step or page amount.\n   */\n  incrementThumb(index: number, stepSize?: number): void,\n  /**\n   * Decrements the value of the thumb by the step or page amount.\n   */\n  decrementThumb(index: number, stepSize?: number): void,\n\n  /**\n   * The step amount for the slider.\n   */\n  readonly step: number,\n\n  /**\n   * The page size for the slider, used to do a bigger step.\n   */\n  readonly pageSize: number,\n\n  /** The orientation of the slider. */\n  readonly orientation: Orientation,\n\n  /** Whether the slider is disabled. */\n  readonly isDisabled: boolean\n}\n\nconst DEFAULT_MIN_VALUE = 0;\nconst DEFAULT_MAX_VALUE = 100;\nconst DEFAULT_STEP_VALUE = 1;\n\nexport interface SliderStateOptions<T> extends SliderProps<T> {\n  numberFormatter: Intl.NumberFormat\n}\n\n/**\n * Provides state management for a slider component. Stores values for all thumbs,\n * formats values for localization, and provides methods to update the position\n * of any thumbs.\n * @param props\n */\nexport function useSliderState<T extends number | number[]>(props: SliderStateOptions<T>): SliderState {\n  const {\n    isDisabled = false,\n    minValue = DEFAULT_MIN_VALUE,\n    maxValue = DEFAULT_MAX_VALUE,\n    numberFormatter: formatter,\n    step = DEFAULT_STEP_VALUE,\n    orientation = 'horizontal'\n  } = props;\n\n  // Page step should be at least equal to step and always a multiple of the step.\n  let pageSize = useMemo(() => {\n    let calcPageSize = (maxValue - minValue) / 10;\n    calcPageSize = snapValueToStep(calcPageSize, 0, calcPageSize + step, step);\n    return Math.max(calcPageSize, step);\n  }, [step, maxValue, minValue]);\n\n  let value = useMemo(() => convertValue(props.value), [props.value]);\n  let defaultValue = useMemo(() => convertValue(props.defaultValue) ?? [minValue], [props.defaultValue, minValue]);\n  let onChange = createOnChange(props.value, props.defaultValue, props.onChange);\n  let onChangeEnd = createOnChange(props.value, props.defaultValue, props.onChangeEnd);\n\n  const [values, setValues] = useControlledState<number[]>(\n    value,\n    defaultValue,\n    onChange\n  );\n  const [isDraggings, setDraggings] = useState<boolean[]>(new Array(values.length).fill(false));\n  const isEditablesRef = useRef<boolean[]>(new Array(values.length).fill(true));\n  const [focusedIndex, setFocusedIndex] = useState<number | undefined>(undefined);\n\n  const valuesRef = useRef<number[]>(null);\n  valuesRef.current = values;\n  const isDraggingsRef = useRef<boolean[]>(null);\n  isDraggingsRef.current = isDraggings;\n\n  function getValuePercent(value: number) {\n    return (value - minValue) / (maxValue - minValue);\n  }\n\n  function getThumbMinValue(index: number) {\n    return index === 0 ? minValue : values[index - 1];\n  }\n  function getThumbMaxValue(index: number) {\n    return index === values.length - 1 ? maxValue : values[index + 1];\n  }\n\n  function isThumbEditable(index: number) {\n    return isEditablesRef.current[index];\n  }\n\n  function setThumbEditable(index: number, editable: boolean) {\n    isEditablesRef.current[index] = editable;\n  }\n\n  function updateValue(index: number, value: number) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n    const thisMin = getThumbMinValue(index);\n    const thisMax = getThumbMaxValue(index);\n\n    // Round value to multiple of step, clamp value between min and max\n    value = snapValueToStep(value, thisMin, thisMax, step);\n    valuesRef.current = replaceIndex(valuesRef.current, index, value);\n    setValues(valuesRef.current);\n  }\n\n  function updateDragging(index: number, dragging: boolean) {\n    if (isDisabled || !isThumbEditable(index)) {\n      return;\n    }\n\n    const wasDragging = isDraggingsRef.current[index];\n    isDraggingsRef.current = replaceIndex(isDraggingsRef.current, index, dragging);\n    setDraggings(isDraggingsRef.current);\n\n    // Call onChangeEnd if no handles are dragging.\n    if (onChangeEnd && wasDragging && !isDraggingsRef.current.some(Boolean)) {\n      onChangeEnd(valuesRef.current);\n    }\n  }\n\n  function getFormattedValue(value: number) {\n    return formatter.format(value);\n  }\n\n  function setThumbPercent(index: number, percent: number) {\n    updateValue(index, getPercentValue(percent));\n  }\n\n  function getRoundedValue(value: number) {\n    return Math.round((value - minValue) / step) * step + minValue;\n  }\n\n  function getPercentValue(percent: number) {\n    const val = percent * (maxValue - minValue) + minValue;\n    return clamp(getRoundedValue(val), minValue, maxValue);\n  }\n\n  function incrementThumb(index: number, stepSize: number = 1) {\n    let s = Math.max(stepSize, step);\n    updateValue(index, snapValueToStep(values[index] + s, minValue, maxValue, step));\n  }\n\n  function decrementThumb(index: number, stepSize: number = 1) {\n    let s = Math.max(stepSize, step);\n    updateValue(index, snapValueToStep(values[index] - s, minValue, maxValue, step));\n  }\n\n  return {\n    values: values,\n    getThumbValue: (index: number) => values[index],\n    setThumbValue: updateValue,\n    setThumbPercent,\n    isThumbDragging: (index: number) => isDraggings[index],\n    setThumbDragging: updateDragging,\n    focusedThumb: focusedIndex,\n    setFocusedThumb: setFocusedIndex,\n    getThumbPercent: (index: number) => getValuePercent(values[index]),\n    getValuePercent,\n    getThumbValueLabel: (index: number) => getFormattedValue(values[index]),\n    getFormattedValue,\n    getThumbMinValue,\n    getThumbMaxValue,\n    getPercentValue,\n    isThumbEditable,\n    setThumbEditable,\n    incrementThumb,\n    decrementThumb,\n    step,\n    pageSize,\n    orientation,\n    isDisabled\n  };\n}\n\nfunction replaceIndex<T>(array: T[], index: number, value: T) {\n  if (array[index] === value) {\n    return array;\n  }\n\n  return [...array.slice(0, index), value, ...array.slice(index + 1)];\n}\n\nfunction convertValue(value: number | number[]) {\n  if (value == null) {\n    return undefined;\n  }\n\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction createOnChange(value, defaultValue, onChange) {\n  return (newValue: number[]) => {\n    if (typeof value === 'number' || typeof defaultValue === 'number') {\n      onChange?.(newValue[0]);\n    } else {\n      onChange?.(newValue);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}